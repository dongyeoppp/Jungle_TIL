## 11주차 pintos VIRTUAL MEMORY 및 알고리즘 문제 풀이

- 2024 - 05 -31 (75일차)   

#### 알고리즘 문제 풀이    
* 14889번 [스타트와 링크](https://github.com/dongyeoppp/Jungle_TIL/blob/main/jungle_week11/bk_14889.py)    

#### Virtual Memory   
* cpu가 실행되기 위해선 프로그램 정보가 memory에 올라가야 한다.  
* 프로그램이 실행 -> fork() : 새로운 프로세스 생성 -> exec() : load()를 호출해서 프로그램을 메모리에 적재한다. -> 적재한 정보를 cpu가 참조하여 연산을 실행한다.   
* cpu가 연산을 실행할 경우   
    * register안에 있는 값을 참조한다. ,register는 매우 빠르지만 용량이 적다.   
    * register의 용량이 작기 때문에 register 보다 좀 느리지만 용량이 더 큰 main memory를 cpu 근처에 둔다.   
    * register와 main memory는 용량이 작고 휘발성이다.   
    * i/o 작업을 할 경우 용량이 더 크고 비휘발성인 disk를 사용한다. (입출력 작업은 시스템에서 데이터를 주고 받는 모든 작업을 가리킨다.)   
* 각각의 프로세스는 가상 주소 공간을 가지고 있으며 mmu(memory management unit)를 통해 논리 주소를 물리주소로 변환한다. (+ mmu는 메모리 보호나 캐시 관리 등 cpu 메모리에 접근하는 것을 총 관리해주는 하드웨어이다.)     
    * mmu에 있는 기준 레지스터(base register)는 가상 주소를 물리 주소로 변환할 때 사용되며 현재 실행되고 있는 프로세스의 물리 메모리의 시작주소가 담겨있다.   
    * 논리 주소 + 기준 레지스터 값으로 물리 주소를 찾는다.  
    *  
* 페이지 테이블   
    * 가상 주소를 물리 주소로 매핑하는데 사용되며 pintos 운영체제에서 ```pml4```를 의미한다.   
    * ```pml4_get_page (uint64_t *pml4, const void *uaddr) ``` : ```pml4```라는 페이지 테이블을 이용하여 가상 주소와 물리 주소 간의 매핑을 확인하고, 해당하는 물리 주소를 찾은 후, 해당하는 물리 주소에 대응하는 커널 가상 주소(커널에 있는 페이지 테이블 엔트리 반환)를 반환한다.  uaddr은 user의 가상 주소를 의미한다.   

* Swap Disk   
    * 메모리 공간의 확장 영역으로 실행되어야 할 여러개의 프로그램이 물리 메모리에 올라가게 될 경우 메모리 공간 부족을 해결할 수 있다.   
    * 물리 메모리 공간이 부족할 경우 실행중인 프로세스의 주소 공간(해당 프로세스의 가상 메모리 공간)을 일시적으로 메모리에서 디스크로 내려놓는다.   
    * swap disk는 disk 상에 file system과 별도로 존재하며 외부 메모리에 존재하지만 물리 메모리의 확장이라고 할 수 있다.   
    * 프로세스가 수행중인 동안에만 일시적으로 저장한다.   
    * 주로 사용되지 않는 페이지 대상으로 swap out을 진행하며, 적절한 페이지 교체 알고리즘을 사용해야 한다.    

* TLB (translation-lookaside buffer)   
    * mmu의 일부로 자주 참조되는 가상 주소 - 실제 주소 변환 정보를 저장하는 하드웨어 캐시이다. 주소 변환을 빠르게 하기 위해 사용한다.   
    * TLB 히트   
        * 가상 주소에서 가상 페이지 번호(VPN)를 추출하고 해당 VPN이 TLB에 존재하는지 확인하여 해당 VPN이 존재할 경우 페이지 프레임 번호(PFN)를 추출한다.   
    * TLB 미스  
        * TLB에 해당 VPN이 존재하지 않는 경우    
        * 1) 페이지 테이블에서 원하는 테이블 엔트리를 찾고 2) 필요한 변환 정보를 추출 3) TLB를 갱신 4) TLB 미스가 발생한 명령어를 재실행한다.   
        * 하드웨어는 예외 시그널을 발생시키고, 예외 시그널을 받은 운영체제는 명령어 실행을 중지한다.   
        * 실행모드를 커널모드로 변경 --> 커널 코드 실행을 준비한다. 커널 모드로 변경이 되면 트랩 핸들러를 실행한다.   
            * 이 트랩 핸들러는 시스템 콜이 호출되었을 때 사용되는 트랩 핸들러와는 다르다.   
            * 시스템 콜을 호출하였을 때의 핸들러는 그 다음 명령어를 실행하기 위한 PC(Program Count ->다시 실행할 명령어의 주소)값을 저장한다.    
            * TLB의 경우 해당 명령어를 다시 실행해야하기 때문에 다음 명령어가 아닌 해당 명령어를 실행하기 위한 PC값을 저장한다. (운영체제는 트랩의 발생원인에 따라 저장해야하는 PC값이 달라진다.)   
    * TLB는 페이지 테이블을 참조하는 횟수를 줄이므로써 큰 성능 개선을 가져온다.   
    * 프로세스가 문맥교환이 일어날 경우 TLB 관리   
        * 주소 공간 식별자인 ```ASID```필드를 추가하여 문맥 전환 시, 운영체제는 새로운 ASID값을 정해진 레지스터에 탑재하여 무슨 프로세스가 실행중인지 파악할 수 있다.   




    



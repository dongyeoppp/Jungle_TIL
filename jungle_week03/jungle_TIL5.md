## cs 개념 정리 및 퀴즈 리뷰 + 문제 풀이   

* 2024 - 04 -09 (23일차)    

#### quiz 리뷰  
* 스택(stack)   
    * 프로시저 호출 시 지역 변수와 매개변수를 저장하기 위한 메모리 공간이다.   
    * 선언되는 순서와 반대로 메모리가 해제되는 LIFO구조를 가지고 있다.   
    * 용도  
        * 함수의 로컬 변수 저장 : 각 함수 호출 시 그 함수의 로컬 변수들이 스택에 저장된다.   
        * 함수의 제어 흐름 관리 : 함수가 다른 함수를 호출할 때, 반환 주소와 이전 함수의 스택 프레임 정보가 스택에 저장된다.   
    * 장점   
        * 동적으로 메모리를 할당하고 해제할 수 있다.  
        * 구현이 간단하며, 메모리 관리 오버헤드가 낮다.  

* 레지스터(register)   
    * 프로세서 내부의 고속 작동 메모리로, 프로시저 실행 중 자주 접근하는 변수나 중간 계산 값을 저장하기 위해 사용된다.  
    * 용도   
        * 중간 연산 결과의 저장 : 연산 중 생성되는 중간 값을 빠르게 저장하고 접근하기 위해 사용한다.  
        * 빠른 데이터 접근 : 특정 데이터나 주소를 빠르게 저장하고 로드하기 위해 사용한다.  
    * 장점   
        * 매우 높은 데이터 접근 속도를 제공한다.  
        * 데이터를 메모리로부터 레지스터로 빠르게 이동시킬 수 있어 연산 효율이 증가한다.   

* 꼬리 재귀 최적화   
    * 재귀 함수 호출 시 호출 스택의 사용을 최적화하는 기법이다.   
    * 재귀 함수가 호출 될 때마다 스택 프레임이 생성되며, 이는 메모리 사용량 증가와 스택 오버플로우의 원인이 된다. 꼬리 재귀 최적화를 통해 재귀함수의 마지막 연산만 호출 스택에 남겨두고 나머지를 제거할 수 있다. 이를 통해 함수가 반환될 때 호출 스택을 재사용할 수 있다.   
    * 꼬리 재귀 함수는 반환값을 바로 return하기 보다 반환값을 파라미터로 전달한다. (이렇게 하면 호출 스택에 쌓이지 않고 후속 호출로 이동한다.)   
    * 마지막 호출에서 스택 프레임을 재활용하므로, 메모리 사용량이 일정하게 유지된다.   
    * 꼬리 재귀는 재귀 호출이 끝나면 아무일도 하지 않고 결과만 바로 반환하도록 하는 방법 이다!! 일반 재귀는 값을 받으면 그 값에 연산을 하고 다른 함수에게 전달하지만 꼬리 재귀는 아무것도 하지 않고 값을 전달한다.   
    * 일반 재귀 구현   
        ```
        int factorial(int n){
            if (n==1){
                return 1;
            }
        }
        return n* factorial(n-1);
        ```
    * 꼬리 
    재귀 최적화 구현   
        ```
        int factorialTail(int n, int acc){
            if(n==1){
                return acc;
            }
            return factorialTail(n-1,n*acc)     # 결과값을 매개변수로 함수에 전달   
        }
        int factorial(int n){
            return factorialTail(n,1);
        }
        ```   

* 그리디 알고리즘(greedy)    
    * 매 순간 가장 좋아 보이는 선택을 하는 알고리즘으로, 지역 최적화를 통해 전역 최적화를 도달하길 기대한다.   
    * 각 단계에서 최적의 해답을 찾아 나가면서 전체 문제의 최적 해답을 찾아나가는 방식이다. 각 단계에서의 결정은 지금까지의 상황만을 고려하며, 이후의 상황은 고려하지 않는다.   
* 동적 프로그래밍(DP)  
    * 복잡한 문제를 여러 개의 작은 하위 문제로 나누어 해결하고, 그 결과를 저장하여 나중에 같은 하위 문제가 다시 발생하면 저장된 결과를 사용하는 알고리즘이다.  
    * 중복된 하위 문제들을 여러 번 해결하는 것을 방지하여 효율성을 높인다.  (메모제이션 또는 타뷸레이션 기법을 사용한다.)   
        * 메모제이션   
            * 연산 결과를 저장해두었다가 중복된 연산이 있으면 재활용하는 방식
        * 타뷸레이션   
            * 문제를 부분 문제로 나눈 다음 작은 문제부터 차례대로 그 결과를 테이블에 저장하는 방식 (계산에 필요하지 않을 수도 있는 값도 미리 계산해 테이블에 저장하고, 이렇게 계산되어 저장된 값을 필요할 때 사용해 빠르게 계산한다.)    
    * 종류   
        * 상향식(Bottom-Up) : 작은 문제부터 차례대로 해결해 나가면서 큰 문제의 해결책을 구한다.   
        * 하향식(Top-Down) : 큰 문제를 작은 문제로 나누어 해결한다.  

#### cs 개념 정리(3.8)   
* ComputerSystem 책을 참고하여 정리하였다. [cs_week03_3]()   

#### 알고리즘 문제 풀이   
* 11049번 [행렬 곱셈 순서]()   

